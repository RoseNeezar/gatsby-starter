{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/neezar/Documents/portfolio/.cache/navigation.js\";\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport loader, { PageResourceStatus } from \"./loader\";\nimport redirects from \"./redirects.json\";\nimport { apiRunner } from \"./api-runner-browser\";\nimport emitter from \"./emitter\";\nimport { RouteAnnouncerProps } from \"./route-announcer-props\";\nimport { navigate as reachNavigate } from \"@reach/router\";\nimport { globalHistory } from \"@reach/router/lib/history\";\nimport { parsePath } from \"gatsby-link\";\nvar redirectMap = redirects.reduce(function (map, redirect) {\n  map[redirect.fromPath] = redirect;\n  return map;\n}, {});\n\nfunction maybeRedirect(pathname) {\n  var redirect = redirectMap[pathname];\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== \"production\") {\n      var pageResources = loader.loadPageSync(pathname);\n\n      if (pageResources != null) {\n        console.error(\"The route \\\"\" + pathname + \"\\\" matches both a page and a redirect; this is probably not intentional.\");\n      }\n    }\n\n    window.___replace(redirect.toPath);\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar onPreRouteUpdate = function onPreRouteUpdate(location, prevLocation) {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(\"onPreRouteUpdate\", {\n      location: location,\n      prevLocation: prevLocation\n    });\n  }\n};\n\nvar onRouteUpdate = function onRouteUpdate(location, prevLocation) {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(\"onRouteUpdate\", {\n      location: location,\n      prevLocation: prevLocation\n    });\n  }\n};\n\nvar navigate = function navigate(to) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _parsePath = parsePath(to),\n      pathname = _parsePath.pathname;\n\n  var redirect = redirectMap[pathname];\n\n  if (redirect) {\n    to = redirect.toPath;\n    pathname = parsePath(to).pathname;\n  }\n\n  if (window.___swUpdated) {\n    window.location = pathname;\n    return;\n  }\n\n  var timeoutId = setTimeout(function () {\n    emitter.emit(\"onDelayedLoadPageResources\", {\n      pathname: pathname\n    });\n    apiRunner(\"onRouteUpdateDelayed\", {\n      location: window.location\n    });\n  }, 1000);\n  loader.loadPage(pathname).then(function (pageResources) {\n    if (!pageResources || pageResources.status === PageResourceStatus.Error) {\n      window.history.replaceState({}, \"\", location.href);\n      window.location = pathname;\n      clearTimeout(timeoutId);\n      return;\n    }\n\n    if (process.env.NODE_ENV === \"production\" && pageResources) {\n      if (pageResources.page.webpackCompilationHash !== window.___webpackCompilationHash) {\n        if (\"serviceWorker\" in navigator && navigator.serviceWorker.controller !== null && navigator.serviceWorker.controller.state === \"activated\") {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: \"clearPathResources\"\n          });\n        }\n\n        console.log(\"Site has changed on server. Reloading browser\");\n        window.location = pathname;\n      }\n    }\n\n    reachNavigate(to, options);\n    clearTimeout(timeoutId);\n  });\n};\n\nfunction shouldUpdateScroll(prevRouterProps, _ref) {\n  var _this = this;\n\n  var location = _ref.location;\n  var pathname = location.pathname,\n      hash = location.hash;\n  var results = apiRunner(\"shouldUpdateScroll\", {\n    prevRouterProps: prevRouterProps,\n    pathname: pathname,\n    routerProps: {\n      location: location\n    },\n    getSavedScrollPosition: function getSavedScrollPosition(args) {\n      return _this._stateStorage.read(args);\n    }\n  });\n\n  if (results.length > 0) {\n    return results[results.length - 1];\n  }\n\n  if (prevRouterProps) {\n    var oldPathname = prevRouterProps.location.pathname;\n\n    if (oldPathname === pathname) {\n      return hash ? decodeURI(hash.slice(1)) : [0, 0];\n    }\n  }\n\n  return true;\n}\n\nfunction init() {\n  globalHistory.listen(function (args) {\n    args.location.action = args.action;\n  });\n\n  window.___push = function (to) {\n    return navigate(to, {\n      replace: false\n    });\n  };\n\n  window.___replace = function (to) {\n    return navigate(to, {\n      replace: true\n    });\n  };\n\n  window.___navigate = function (to, options) {\n    return navigate(to, options);\n  };\n\n  maybeRedirect(window.location.pathname);\n}\n\nvar RouteAnnouncer = function (_React$Component) {\n  _inherits(RouteAnnouncer, _React$Component);\n\n  var _super = _createSuper(RouteAnnouncer);\n\n  function RouteAnnouncer(props) {\n    var _this2;\n\n    _classCallCheck(this, RouteAnnouncer);\n\n    _this2 = _super.call(this, props);\n    _this2.announcementRef = React.createRef();\n    return _this2;\n  }\n\n  _createClass(RouteAnnouncer, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, nextProps) {\n      var _this3 = this;\n\n      requestAnimationFrame(function () {\n        var pageName = \"new page at \" + _this3.props.location.pathname;\n\n        if (document.title) {\n          pageName = document.title;\n        }\n\n        var pageHeadings = document.querySelectorAll(\"#gatsby-focus-wrapper h1\");\n\n        if (pageHeadings && pageHeadings.length) {\n          pageName = pageHeadings[0].textContent;\n        }\n\n        var newAnnouncement = \"Navigated to \" + pageName;\n        var oldAnnouncement = _this3.announcementRef.current.innerText;\n\n        if (oldAnnouncement !== newAnnouncement) {\n          _this3.announcementRef.current.innerText = newAnnouncement;\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", _extends({}, RouteAnnouncerProps, {\n        ref: this.announcementRef,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 187,\n          columnNumber: 12\n        }\n      }));\n    }\n  }]);\n\n  return RouteAnnouncer;\n}(React.Component);\n\nvar RouteUpdates = function (_React$Component2) {\n  _inherits(RouteUpdates, _React$Component2);\n\n  var _super2 = _createSuper(RouteUpdates);\n\n  function RouteUpdates(props) {\n    var _this4;\n\n    _classCallCheck(this, RouteUpdates);\n\n    _this4 = _super2.call(this, props);\n    onPreRouteUpdate(props.location, null);\n    return _this4;\n  }\n\n  _createClass(RouteUpdates, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      onRouteUpdate(this.props.location, null);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState, shouldFireRouteUpdate) {\n      if (shouldFireRouteUpdate) {\n        onRouteUpdate(this.props.location, prevProps.location);\n      }\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate(prevProps) {\n      if (this.props.location.pathname !== prevProps.location.pathname) {\n        onPreRouteUpdate(this.props.location, prevProps.location);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(React.Fragment, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 219,\n          columnNumber: 7\n        }\n      }, this.props.children, React.createElement(RouteAnnouncer, {\n        location: location,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 221,\n          columnNumber: 9\n        }\n      }));\n    }\n  }]);\n\n  return RouteUpdates;\n}(React.Component);\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired\n};\nexport { init, shouldUpdateScroll, RouteUpdates };","map":{"version":3,"sources":["/Users/neezar/Documents/portfolio/.cache/navigation.js"],"names":["React","PropTypes","loader","PageResourceStatus","redirects","apiRunner","emitter","RouteAnnouncerProps","navigate","reachNavigate","globalHistory","parsePath","redirectMap","reduce","map","redirect","fromPath","maybeRedirect","pathname","process","env","NODE_ENV","pageResources","loadPageSync","console","error","window","___replace","toPath","onPreRouteUpdate","location","prevLocation","onRouteUpdate","to","options","___swUpdated","timeoutId","setTimeout","emit","loadPage","then","status","Error","history","replaceState","href","clearTimeout","page","webpackCompilationHash","___webpackCompilationHash","navigator","serviceWorker","controller","state","postMessage","gatsbyApi","log","shouldUpdateScroll","prevRouterProps","hash","results","routerProps","getSavedScrollPosition","args","_stateStorage","read","length","oldPathname","decodeURI","slice","init","listen","action","___push","replace","___navigate","RouteAnnouncer","props","announcementRef","createRef","prevProps","nextProps","requestAnimationFrame","pageName","document","title","pageHeadings","querySelectorAll","textContent","newAnnouncement","oldAnnouncement","current","innerText","Component","RouteUpdates","prevState","shouldFireRouteUpdate","children","propTypes","object","isRequired"],"mappings":"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","sourcesContent":["import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport loader, { PageResourceStatus } from \"./loader\"\nimport redirects from \"./redirects.json\"\nimport { apiRunner } from \"./api-runner-browser\"\nimport emitter from \"./emitter\"\nimport { RouteAnnouncerProps } from \"./route-announcer-props\"\nimport { navigate as reachNavigate } from \"@reach/router\"\nimport { globalHistory } from \"@reach/router/lib/history\"\nimport { parsePath } from \"gatsby-link\"\n\n// Convert to a map for faster lookup in maybeRedirect()\nconst redirectMap = redirects.reduce((map, redirect) => {\n  map[redirect.fromPath] = redirect\n  return map\n}, {})\n\nfunction maybeRedirect(pathname) {\n  const redirect = redirectMap[pathname]\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== `production`) {\n      const pageResources = loader.loadPageSync(pathname)\n\n      if (pageResources != null) {\n        console.error(\n          `The route \"${pathname}\" matches both a page and a redirect; this is probably not intentional.`\n        )\n      }\n    }\n\n    window.___replace(redirect.toPath)\n    return true\n  } else {\n    return false\n  }\n}\n\nconst onPreRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onPreRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst onRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst navigate = (to, options = {}) => {\n  let { pathname } = parsePath(to)\n  const redirect = redirectMap[pathname]\n\n  // If we're redirecting, just replace the passed in pathname\n  // to the one we want to redirect to.\n  if (redirect) {\n    to = redirect.toPath\n    pathname = parsePath(to).pathname\n  }\n\n  // If we had a service worker update, no matter the path, reload window and\n  // reset the pathname whitelist\n  if (window.___swUpdated) {\n    window.location = pathname\n    return\n  }\n\n  // Start a timer to wait for a second before transitioning and showing a\n  // loader in case resources aren't around yet.\n  const timeoutId = setTimeout(() => {\n    emitter.emit(`onDelayedLoadPageResources`, { pathname })\n    apiRunner(`onRouteUpdateDelayed`, {\n      location: window.location,\n    })\n  }, 1000)\n\n  loader.loadPage(pathname).then(pageResources => {\n    // If no page resources, then refresh the page\n    // Do this, rather than simply `window.location.reload()`, so that\n    // pressing the back/forward buttons work - otherwise when pressing\n    // back, the browser will just change the URL and expect JS to handle\n    // the change, which won't always work since it might not be a Gatsby\n    // page.\n    if (!pageResources || pageResources.status === PageResourceStatus.Error) {\n      window.history.replaceState({}, ``, location.href)\n      window.location = pathname\n      clearTimeout(timeoutId)\n      return\n    }\n\n    // If the loaded page has a different compilation hash to the\n    // window, then a rebuild has occurred on the server. Reload.\n    if (process.env.NODE_ENV === `production` && pageResources) {\n      if (\n        pageResources.page.webpackCompilationHash !==\n        window.___webpackCompilationHash\n      ) {\n        // Purge plugin-offline cache\n        if (\n          `serviceWorker` in navigator &&\n          navigator.serviceWorker.controller !== null &&\n          navigator.serviceWorker.controller.state === `activated`\n        ) {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: `clearPathResources`,\n          })\n        }\n\n        console.log(`Site has changed on server. Reloading browser`)\n        window.location = pathname\n      }\n    }\n    reachNavigate(to, options)\n    clearTimeout(timeoutId)\n  })\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location }) {\n  const { pathname, hash } = location\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    // `pathname` for backwards compatibility\n    pathname,\n    routerProps: { location },\n    getSavedScrollPosition: args => this._stateStorage.read(args),\n  })\n  if (results.length > 0) {\n    // Use the latest registered shouldUpdateScroll result, this allows users to override plugin's configuration\n    // @see https://github.com/gatsbyjs/gatsby/issues/12038\n    return results[results.length - 1]\n  }\n\n  if (prevRouterProps) {\n    const {\n      location: { pathname: oldPathname },\n    } = prevRouterProps\n    if (oldPathname === pathname) {\n      // Scroll to element if it exists, if it doesn't, or no hash is provided,\n      // scroll to top.\n      return hash ? decodeURI(hash.slice(1)) : [0, 0]\n    }\n  }\n  return true\n}\n\nfunction init() {\n  // The \"scroll-behavior\" package expects the \"action\" to be on the location\n  // object so let's copy it over.\n  globalHistory.listen(args => {\n    args.location.action = args.action\n  })\n\n  window.___push = to => navigate(to, { replace: false })\n  window.___replace = to => navigate(to, { replace: true })\n  window.___navigate = (to, options) => navigate(to, options)\n\n  // Check for initial page-load redirect\n  maybeRedirect(window.location.pathname)\n}\n\nclass RouteAnnouncer extends React.Component {\n  constructor(props) {\n    super(props)\n    this.announcementRef = React.createRef()\n  }\n\n  componentDidUpdate(prevProps, nextProps) {\n    requestAnimationFrame(() => {\n      let pageName = `new page at ${this.props.location.pathname}`\n      if (document.title) {\n        pageName = document.title\n      }\n      const pageHeadings = document.querySelectorAll(`#gatsby-focus-wrapper h1`)\n      if (pageHeadings && pageHeadings.length) {\n        pageName = pageHeadings[0].textContent\n      }\n      const newAnnouncement = `Navigated to ${pageName}`\n      const oldAnnouncement = this.announcementRef.current.innerText\n      if (oldAnnouncement !== newAnnouncement) {\n        this.announcementRef.current.innerText = newAnnouncement\n      }\n    })\n  }\n\n  render() {\n    return <div {...RouteAnnouncerProps} ref={this.announcementRef}></div>\n  }\n}\n\n// Fire on(Pre)RouteUpdate APIs\nclass RouteUpdates extends React.Component {\n  constructor(props) {\n    super(props)\n    onPreRouteUpdate(props.location, null)\n  }\n\n  componentDidMount() {\n    onRouteUpdate(this.props.location, null)\n  }\n\n  componentDidUpdate(prevProps, prevState, shouldFireRouteUpdate) {\n    if (shouldFireRouteUpdate) {\n      onRouteUpdate(this.props.location, prevProps.location)\n    }\n  }\n\n  getSnapshotBeforeUpdate(prevProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      onPreRouteUpdate(this.props.location, prevProps.location)\n      return true\n    }\n\n    return false\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.props.children}\n        <RouteAnnouncer location={location} />\n      </React.Fragment>\n    )\n  }\n}\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired,\n}\n\nexport { init, shouldUpdateScroll, RouteUpdates }\n"]},"metadata":{},"sourceType":"module"}